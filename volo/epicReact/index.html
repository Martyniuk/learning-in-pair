<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KCD Course</title>
  </head>
  <body>
    <section>
      <h2>Epic React Course</h2>
      <ol>
        <li>
          Fundamentals
          <ul>
            <li>add content about 1st course</li>
          </ul>
        </li>
        <li>
          Hooks
          <ul>
            <li>
              useState hook:
              <ul>
                important to remember:
                <li>initValue - <code>useState(0)</code></li>
                <li>
                  initValue - <code>useState(() => 0)</code>
                  <p>callback means Lazy initialization</p>
                  <p>
                    in case initValue is computed by expensive operation - use
                    callback
                  </p>
                  <ul>
                    examples of potential cases
                    <li>
                      getting init value from localStorage, cookie, indexDB
                    </li>
                    <li>iterations over Array with > O(N) complexity</li>
                  </ul>
                </li>
                <li>update state - <code>setCount(count)</code></li>
                <li>
                  update state -
                  <code>setCount(prevCount => prevCount + 1)</code>
                </li>
                <li>
                  update state -
                  <code>setUser({ name, email })</code>
                  <p>
                    you can use object as state to manage few fields and dont
                    have multiple useStates, but setUser works not as
                    this.setState!!! it's not merging state, it Overwrites it!
                    so use callback in setUser
                  </p>
                </li>
              </ul>
            </li>
            <li>
              useEffect hook
              <ul>
                important to remember:
                <li>
                  Behaives as didMount, didUpdate, Unmount lifecycles in class
                  component
                  <p>didMount - fires on initial render of a FC</p>
                  <p>didUpdate -
                      <ul>
                          <li>if you pass NO second argument - it fires</li>
                          <li>if you pass EMPTY ARRAY as second argument - [] - if fires only ONCE</li>
                          <li>if you pass ARRAY of dependencies as second argument - [] - if fires only if some of this dependencies changes</li>
                      </ul>
                  </p>
                  <p>Unmount - cleaning up phase - you may return Callback that will fire only before Component leaves the screen.</p>
                </li>
                <li>
                    Function passed to useEffect fires <strong>AFTER</strong> layout and paint, during deferred event.
                </li>
                <li>
                    fetching data in useEffect refer to <a href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">REACT DOC</a>
                </li>
              </ul>
            </li>
            <li>
              custom hooks
              <ul>
                important to remember
                <li>
                  every custom hook should have name to start from "use", it is
                  needed for eslint rules to check violation, if function
                  contains hooks inside
                </li>
              </ul>
            </li>
            <li>
                useLayoutEffect hook
                <p>the same one as useEffect, the diff is in When it fires</p>
                <p>if fires before the browser has a chance to paint</p>
                <p>NOTE! prefer standard useEffect when possible</p>
            </li>
            <li>useReducer hook</li>
            <li>useCallback hook - return memoized callback</li>
            <li>useMemo hook - return memoized value</li>
            <li>useRef hook - return mutable ref object, where .current is initialized to the passed argument</li>
            <li>useImperativeHandle hook - ?</li>
            <li>useDebugValue hook - can be used to display label for custom hooks</li>

            <li>Lifting state - colocating state - what does it mean? - your state should be as close as possible to place where it is used</li>
            <li>
                tic-tac-toe game made in React (refer README file for serving production build of a project)
            </li>
            <li>
                <p>useRef usage with Tilt</p>
                <p>practice refactoring Class component into Function component</p>
            </li>
            <li>fetching pokemons data
                <ul>
                    <li>fetch data in useEffect</li>
                    <li>having error state</li>
                    <li>having status - 'idle', 'pending', 'rejected', 'resolved'</li>
                    <li>adding ErrorBoundary - a component that catches error and renders FallbackComponent for better UX.<br>
                        <ul>NOTE: Error Boundaries do NOT catch errors for:
                            <li>EventHandlers</li>
                            <li>Async Code</li>
                            <li>Server Side rendering</li>
                            <li>Errors thrown in error boundary itself</li>
                            <li>--------</li>
                            <li>use key prop to make ErrorBoundary reset state</li>
                            <li>using package react-error-boundary + onReset eventHandler + resetKeys array</li>
                        </ul>
                    </li>
                </ul>
            </li>
          </ul>
        </li>
        <li>Advanced Hooks
          <ul>
            <li>useReducer - Redux approach vs React approach</li>
            <li>useCallback
              <ul>
                <li>React.memo cont and pros + React.useCallback, React.useMemo - as a result possibly it is a case to move logic inside of useEffect</li>
                <li>AHA programming vs DRY, WET</li>
                <li>Closures</li>
                <li>Use case: if I call fetch - I receive response, but what if I will move to another page in between "request <- here --> response"? I will receive response anyway and I should not update my state, coz component which state should be updated is already unmounted!!
                  <ul>solution:
                    <li>create wrapper over dispatch function that is gonna know when our component is mounted:</li>
                    <li>How? - create custom hook with boolean variable "mounted" to be false, inside of that function we need to have useEffect(useLayoutEffect) to have logic - ref.current = true (mounted) and return clean up function ref.current = false (unmounted), dependency should be empty array (runs only once)</li>
                    <li>custom hook should return function that will be called only in case component is mounted -> (...rest) => { if (ref.current) {dispatch(...rest)}}</li>
                    <li>
                      full code:
                      <textarea name="checkIfComponentIsMounted" id="checkIfComponentIsMounted" cols="80" rows="20" disabled>
                        function useSafeDispatch(dispatch) {
                          const mountedRef = React.useRef(false)

                          React.useEffect(() => {
                            mountedRef.current = true
                            return () => {
                              mountedRef.current = false
                            }
                          }, [])

                          return React.useCallback(
                            (...rest) => {
                              if (mountedRef.current) {
                                dispatch(...rest)
                              }
                            },
                            [dispatch],
                          )
                        }
                      </textarea>
                    </li>
                    <li>AbortController API - uh very interesting one</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>useContext
              <ul>
                <li>Prop drilling <a href="https://kentcdodds.com/blog/prop-drilling">LINK to Source</a></li>
                <li>Example of Application Context with useReducer ðŸ‘‰
                  <textarea name="wrapperOverApp" id="wrapperOverApp" cols="100" rows="25" disabled>
                    import * as React from 'react'
                    const CountContext = React.createContext()
                    function countReducer(state, action) {
                      switch (action.type) {
                        case 'increment': {
                          return {count: state.count + 1}
                        }
                        case 'decrement': {
                          return {count: state.count - 1}
                        }
                        default: {
                          throw new Error(`Unhandled action type: ${action.type}`)
                        }
                      }
                    }
                    function CountProvider({children}) {
                      const [state, dispatch] = React.useReducer(countReducer, {count: 0})
                      // NOTE: you *might* need to memoize this value
                      // Learn more in http://kcd.im/optimize-context
                      const value = {state, dispatch}
                      return <CountContext.Provider value={value}>{children}</CountContext.Provider>
                    }
                    export {CountProvider}
                  </textarea>
                </li>
                <li>Dont use default value in createContext function, it can lead to unpredicted UX</li>
                <li>handling scenario when Context is accessed outside the Context.Provider(and no default value provided) - very practical example of handling it.</li>
                <li>lesson with mostly practicing everything above about Context</li>
              </ul>
            </li>
            <li>useLayoutEffect
              <ul>
                <li>Reflow vs Repaint - <a href="https://dev.to/gopal1996/understanding-reflow-and-repaint-in-the-browser-1jbg">Article</a></li>
              </ul>
            </li>
            <li>useImperativeHandle - best explanation and use cases <a href="https://stackoverflow.com/questions/57005663/when-to-use-useimperativehandle-uselayouteffect-and-usedebugvalue">HERE</a>
              <ul>
                <li>React.forwardRef - Parent component created ref and this ref is passed to children and in order to use this ref - use forwardRef on a children.( why? - coz ref can't be passed to function component, it will be undefined)</li>
              </ul>
            </li>
            <li>useDebugValue - only for custom hooks debugging purpose</li>
          </ul>
        </li>
      </ol>
    </section>
  </body>
</html>
